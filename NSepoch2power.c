#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>
#include <string.h>
#include <ctype.h>

#define NA		3		/* general artifact quantitation dimension */
#define ARTHRESH0	80.0		/* instantaneous general artifact threshold */
#define ARTHRESH1	35.0		/* averaged      general artifact threshold */
#define MAXL		2048		/* filename character length */
#define MAXT		8		/* character length of channel label */
#define MAXC		66		/* maximum number of channels */
#define ACHAN		20		/* number of artifact quantitation channels */
#define NBAND		6		/* number of frequency bands */
#define IBAD		0		/* number of initial bad timepoints */
#define SDCRIT		24.0		/* spike detector criterion */
#define TWO		2
#define TRAILER		1		/* for those that choose not to specify the trailer */
#define POINTS		512		/* default point value for epoching */

void errm (char* program) {
	fprintf (stderr, "%s: memory allocation error\n", program);
	exit (-1);
}

void errr (char* program, char* filespc) {
	fprintf (stderr, "%s: %s read error\n", program, filespc);
	exit (-1);
}

void errw (char* program, char* filespc) {
	fprintf (stderr, "%s: %s write error\n", program, filespc);
	exit (-1);
}

void getroot (char *filespc, char *filroot) {
	char	*str;
	strcpy (filroot, filespc);
	while (str = strrchr (filroot, '.')) {
			if (!strcmp (str, ".rec"))	*str = '\0';
		else	if (!strcmp (str, ".dat"))	*str = '\0';
		else	if (!strcmp (str, ".lay"))	*str = '\0';
		else	if (!strcmp (str, ".ev2"))	*str = '\0';
		else	break;
	}
}

int split (char *string, char *srgv[], int maxp) {
	int	i, m;
	char	*ptr;

	if (ptr = strchr (string, '#')) *ptr = '\0';
/**********************************/
/* convert '[', ']', ',' to space */
/**********************************/
	ptr = string; while (ptr = strpbrk (ptr, "[],")) *ptr = '\x20';
	i = m = 0;
	while (m < maxp) {
		while (!isgraph ((int) string[i]) && string[i]) i++;
		if (!string[i]) break;
		srgv[m++] = string + i;
		while (isgraph ((int) string[i])) i++;
		if (!string[i]) break;
		string[i++] = '\0';
	}
	return m;
}

double zeromean (float *f, int n) {
	int		i;
	double		u;

	for (u = i = 0; i < n; i++) u += f[i];
	u /= n;
	for (i = 0; i < n; i++) f[i] -= u;
	return u;
}

double unitvar (float *f, int npts) {
	int		i;
	double		v;

	for (v = i = 0; i < npts; i++) v += f[i]*f[i];
	v /= npts; v = sqrt (v);
	for (i = 0; i < npts; i++) f[i] /= v;
	return v;
}

void usage (char *program) {
	fprintf (stderr, "Usage:\t%s <datfile>\n", program);
	fprintf (stderr, "e.g.,\t%s 04_1004_ascii[.dat] -pcOZ\n", program);
	fprintf (stderr, "\toption\n");
	fprintf (stderr, "\t-a\tdump general artifact quantitation record\n");
	fprintf (stderr, "\t-e<int>\tdump selected sweep (counting from 1; all channels)\n");
	fprintf (stderr, "\t-t<str>\tdump selected channel (all sweeps)\n");
	fprintf (stderr, "\t-r<str>\tremove specified channel from artifact quantitation\n");
	fprintf (stderr, "\t-i<int>\tcorrect specified number initial bad timepoints (default = %d)\n", IBAD);
	fprintf (stderr, "\t-s<flt>\tspecify spike detector s.d. criterion (default = %.2f)\n", SDCRIT);
	fprintf (stderr, "\t-g<0|1><flt>\tspecify general artifact threshold (default = {%.2f, %.2f})\n",
			ARTHRESH0, ARTHRESH1);
	fprintf (stderr, "\t-c<str>\toutput power timecourse for specified channel\n");
	fprintf (stderr, "\t-p\tcreate averaged psd file for (the same) specified channel\n");
	fprintf (stderr, "\t-z<layfile>\tuse artifact files generated by John instead of automated artifact detection\n");
	fprintf (stderr, "\t-N<str>\toutput NeuroScan '.dat' file in ascii format with trailer\n");	
	fprintf (stderr, "\t-P<int>\tspecify number of points for epoched FFT (default=%i)\n", POINTS);
	fprintf (stderr, "\t-E<eventfile>\tuse event file to locate the first acquired MR frame\n");
	fprintf (stderr, "\t-d\tdebug mode\n");
	exit (1);
}

/********************/
/* global variables */
/********************/
char		rcsid[] = "$Id: NSepoch2power.c,v 1.20 2006/12/18 02:37:38 avi Exp $";
char		program[MAXL];
int		debug = 0;

float ***calloc_float3 (int n1, int n2, int n3) {
	int	i, j;
	float	***a;

	if (!(a = (float ***) malloc (n1 * sizeof (float **)))) errm (program);
	for (i = 0; i < n1; i++) {
		if (!(a[i] = (float **) malloc (n2 * sizeof (float *)))) errm (program);
		for (j = 0; j < n2; j++) {
			if (!(a[i][j] = (float *) calloc (n3, sizeof (float)))) errm (program);
		}
	}
	return a;
}

float **calloc_float2 (int n1, int n2) {
	int	i;
	float	**a;

	if (!(a = (float **) malloc (n1 * sizeof (float *)))) errm (program);
	for (i = 0; i < n1; i++) {
		if (!(a[i] = (float *) calloc (n2, sizeof (float)))) errm (program);
	}
	return a;
}

void free_float3 (float ***a, int n1, int n2) {
	int	i, j;

	for (i = 0; i < n1; i++) {
		for (j = 0; j < n2; j++) free (a[i][j]);
		free (a[i]);
	}
	free (a);
}

void free_float2 (float **a, int n1) {
	int	i;

	for (i = 0; i < n1; i++) free (a[i]);
	free (a);
}

/*************/
/* externals */
/*************/
extern void	fft_   (float *a, float *b, int *nseg, int *n, int *nspn, int *idir);	/* FORTRAN librms */
extern void	realt_ (float *a, float *b, int *nseg, int *n, int *nspn, int *idir);	/* FORTRAN librms */

int main (int argc, char *argv[]) {
	char		*ptr, command[MAXL], string[4*MAXL], *srgv[MAXL];
	int		c, i, j, k, l, m, n;

/************/
/* file i/o */
/************/
	FILE		*datfp, *outfp, *layfp, *evfp;
	char		datroot[MAXL], datfile[MAXL], outfile[MAXL];
	char		evroot[MAXL], evfile[MAXL];
	char		layroot[MAXL], layfile[MAXL];
	char		NSoutfile[MAXL];
	char		trailer[MAXL];

/*****************/
/* EEG variables */
/*****************/
	char		time[MAXL], date[MAXL];
	char		rows[MAXL];
	int		channels;
	char		trode[MAXC][MAXT];
	float		rate, delta;		/* sampling rate in Hz */
	int		nchan, nbin, ichan, jchan, schan, npts, nsweep, isweep, ksweep, pointsbeforeMR = 0;
	float		***eeg;			/*     eeg[ichan][isweep][ipoint] */
	float		***trodsd;		/*     trodsd[ichan][isweep][i]  	  */
	float		***bandpwr;		/* bandpwr[ichan][isweep][iband]  */
	float		**psd;			/*     psd[ichan][ipoint] */
	float		bandlim[NBAND] = {4., 8., 12., 16., 23., 30.};
	char		*bandlabel[NBAND] = {"delta", "theta", "alpha", "beta1", "beta2", "beta3"};
	int		iband, nband = NBAND;
	int		*accept;		/* accept[isweep] */
	int		*frame;
	int		nframe, iframe;

/****************************/
/* spike artifact reduction */
/****************************/
	int		ibad = IBAD;
	int		isweepp, isweepm, ip, im, nspike;
	double		q, q1, q2, sign;
	double		sdcrit = SDCRIT;

/*********************************/
/* general artifact quantitation */
/*********************************/
	int		ii, i1, i2;
	char		artrode[ACHAN][MAXT] = {"O1", "OZ", "O2", "P7", "P3", "PZ", "P4", "P8", "C3", "CZ", "C4",
						"F7", "F3", "FZ", "F4", "F8", "T7", "T3", "T4", "T8"};
	float		*artifact[NA], w;
	float		aitime = .25;	/* artifact integration time in seconds */
	double		artsum[2], artvar[2], arthresh[2] = {ARTHRESH0, ARTHRESH1};
	int 		*zempart, *zempdur;

/*******/
/* FFT */
/*******/
	float		*a, *b;
	float		var, sum, totpwr;
	float		hzpbin;
	int		one = 1, negone = -1, no2;

/*********/
/* flags */
/*********/
	int		psdflag = 0;
	int		status = 0;
	int		idump = -1;
	int		artdump = 0;
	char		pwrchan[MAXL] = "";
	char		dumpchan[MAXL] = "";
	int		zempel = 0;
	int		outputNS = 0;
	int		events = 0;
	int		points = POINTS;
	int		type;

	printf ("#%s\n", rcsid);
	if (!(ptr = strrchr (argv[0], '/'))) ptr = argv[0]; else ptr++;
	strcpy (program, ptr);
/************************/
/* process command line */
/************************/
	for (k = 0, i = 1; i < argc; i++) {
		if (*argv[i] == '-') {
			strcpy (command, argv[i]); ptr = command;
			while (c = *ptr++) switch (c) {
				case 'a': artdump++;			break;
				case 'd': debug++;			break;
				case 'p': psdflag++;			break;
				case 'g': switch (*ptr++) {
						case 0: arthresh[0] = atof (ptr); break;
						case 1: arthresh[1] = atof (ptr); break;
					  }				     *ptr = '\0'; break;
				case 's': sdcrit = atof (ptr);		     *ptr = '\0'; break;
				case 'i': ibad = atoi (ptr);		     *ptr = '\0'; break;
				case 'e': idump = atoi (ptr) - 1;	     *ptr = '\0'; break;
				case 'c': strcpy (pwrchan, ptr);	     *ptr = '\0'; break;
				case 't': strcpy (dumpchan, ptr);	     *ptr = '\0'; break;
				case 'r': for (jchan = 0; jchan < ACHAN; jchan++) {
						if (!strcmp (artrode[jchan], ptr)) artrode[jchan][0] = '\0';
					  }				     *ptr = '\0'; break;
				case 'z': zempel++; getroot (ptr, layroot);  *ptr = '\0'; break;
				case 'N': outputNS++; strcpy (trailer, ptr); *ptr = '\0'; break;
				case 'P': points = atoi (ptr);		     *ptr = '\0'; break;
				case 'E': getroot (ptr, evroot); events++;   *ptr = '\0'; break;
			}
		}
		else switch (k) {
			case 0:	getroot (argv[i], datroot);	k++; break;
		}	
	}
	if (k < 1) usage (program);

if (events) {
/********************/
/* parse event file */
/********************/
	sprintf (evfile, "%s.ev2", evroot);
	fprintf (stderr, "#Reading: %s\n", evfile);
	if (!(evfp = fopen (evfile, "r"))) errr (program, evfile);
	nframe = 0;
	do {
		if (split (string, srgv, MAXL)) nframe++;
	} while (fgets (string, 4*MAXL, evfp));
	rewind (evfp);
	if (!(frame = (int *) calloc (nframe, sizeof (int)))) errm (program);
	for (iframe = 0; iframe < nframe; iframe++) {
		fgets (string, 4*MAXL, evfp);
		split (string, srgv, MAXL);
		frame[iframe] = atoi (srgv[5]);
	}
	if (fclose (evfp)) errr (program, evfile);
	pointsbeforeMR = frame[0];
	fprintf (stderr, "pointsbeforeMR=%d\n", pointsbeforeMR);
}

/******************/
/* parse dat file */
/******************/
	sprintf (datfile, "%s.dat", datroot);
	fprintf (stderr, "#Reading: %s\n", datfile);
	if (!(datfp = fopen (datfile, "r"))) errr (program, datfile);
	do {
		fgets (string, 4*MAXL, datfp);
		m = split (string, srgv, MAXL);
		if (!strcmp (srgv[0], "Date"))		strcpy (date, srgv[1]);
		if (!strcmp (srgv[0], "Time"))		strcpy (time, srgv[1]);
		if (!strcmp (srgv[0], "Channels"))	channels =  atoi (srgv[1]);
		if (!strcmp (srgv[0], "Rate"))		rate = atof (srgv[1]);
		if (!strcmp (srgv[0], "Type"))		type = !strcmp (srgv[1], "Continuous");
		if (!strcmp (srgv[0], "Rows"))		strcpy (rows, srgv[1]);		
		if (!strcmp (srgv[0], "Electrode")	&& !strcmp (srgv[1], "Labels")) {
			fgets (string, 4*MAXL, datfp);
			nchan = split (string, srgv, MAXC);
			for (i = 0; i < nchan; i++) strcpy (trode[i], srgv[i]);
		}
	} while (strcmp (srgv[0], "Continuous"));
	fgets (string, 4*MAXL, datfp);
	npts = 0;
	do {
		if (split (string, srgv, MAXL) != nchan) {
			fprintf (stderr, "%s: %s parse error\n", program, datfile);
			exit (-1);
		}
		npts++;
	} while (fgets (string, 4*MAXL, datfp));
	for (i = 0; i < nchan; i++) fprintf (stderr, "#channel %d %s\n", i + 1, trode[i]);
	if (!type) {
		fprintf (stderr, "%s: %s is not continous data\n", program, datfile);
		exit (-1);
	}
	nsweep = (npts - pointsbeforeMR)/points;
	eeg = calloc_float3 (nchan, nsweep, points);
	rewind (datfp);
	do {
		fgets (string, 4*MAXL, datfp);
		split (string, srgv, MAXL);
	} while (strcmp (srgv[0], "Continuous"));

/******************************/
/* advance past pre-MR record */
/******************************/
	for (i = 0; i < pointsbeforeMR; i++) fgets (string, 4*MAXL, datfp); 
	for (isweep = 0; isweep < nsweep; isweep++) {
		for (i = 0; i < points; i++) {
			fgets (string, 4*MAXL, datfp);
			split (string, srgv, MAXL);
			for (ichan = 0; ichan < nchan; ichan++) eeg[ichan][isweep][i] = atof (srgv[ichan]);
		}
	}
	if (fclose (datfp)) errr (program, datfile);

/***********************/
/* allocate EEG memory */
/***********************/
	no2 = points/2;
	nbin = no2 + 1;
	for (k = 0; k < NA; k++) if (!(artifact[k] = (float *) calloc (nsweep*points, sizeof (float)))) errm (program);
	if (!(accept = (int *) calloc (nsweep, sizeof (int)))) errm (program);
	if (!(a = (float *) malloc (nbin * sizeof (float)))) errm (program);
	if (!(b = (float *) malloc (nbin * sizeof (float)))) errm (program);
	if (!(zempart = (int *) calloc (MAXL, sizeof (int)))) errm (program);
	if (!(zempdur = (int *) calloc (MAXL, sizeof (int)))) errm (program);
	psd	= calloc_float2 (nchan, nbin);
	trodsd  = calloc_float3 (nchan, nsweep, NA);
	bandpwr = calloc_float3 (nchan, nsweep, nband);
	fprintf (stderr, "#sweep count = %d\n", nsweep);

/************************/
/* verify correct input */
/************************/
	if (debug) {
		ichan = 1;
		isweep = 1;
		for (i = 0; i < 50; i++) printf ("#channel=%s  data point=%d  sample=%d\t%10.4f\n",
			trode[ichan], isweep*points + pointsbeforeMR, i, eeg[ichan][isweep][i]);
	}
	delta = 1./rate;
	hzpbin = rate/points;
	fprintf (stderr, "#rate=%.4f hzpbin=%f\n", rate, hzpbin);

/****************************/
/* remove initital artifact */
/****************************/
	if (ibad) {
		printf ("#removed bad initial points count = %d\n", ibad);
		for (ichan = 0; ichan < nchan; ichan++) {
			for (i = 0; i < ibad; i++) eeg[ichan][0][i] = eeg[ichan][0][ibad];
		}
	}

/*************************/
/* remove spike artifact */
/*************************/
	for (n = sum = var = isweep = 0; isweep < nsweep; isweep++) {
		for (i = 0; i < points; i++) {
			ip = (i + 1) % points; isweepp = isweep; if (!ip) isweepp++;
			im = (i + points - 1) % points; isweepm = isweep; if (!i) isweepm--;
			if (isweepm < 0 || isweepp == nsweep) break;
			for (q = ichan = 0; ichan < nchan; ichan++) {
				q += .5*fabs (2.*eeg[ichan][isweep][i] - eeg[ichan][isweepp][ip]
								       - eeg[ichan][isweepm][im]);
			}
			n++; sum += q; var += q*q;
		}
	}
	sum /= n; var /= n; var -= sum*sum;
	printf ("#spike measure mean and s.d. %10.4f%10.4f\n", sum, sqrt(var));
	for (nspike = isweep = 0; isweep < nsweep; isweep++) {
		for (i = 0; i < points; i++) {
			ip = (i + 1) % points; isweepp = isweep; if (!ip) isweepp++;
			im = (i + points - 1) % points; isweepm = isweep; if (!i) isweepm--;
			if (isweepm < 0 || isweepp == nsweep) break;
			for (q1 = q2 = ichan = 0; ichan < nchan; ichan++) {
				sign =  (2.*eeg[ichan][isweep][i] - eeg[ichan][isweepp][ip]
								  - eeg[ichan][isweepm][im] > 0.) ? +1. : -1.;
				q1 += sign*(eeg[ichan][isweep][i] - eeg[ichan][isweepp][ip]);
				q2 += sign*(eeg[ichan][isweep][i] - eeg[ichan][isweepm][im]);
			}
			q = sdcrit*sqrt(var) - sum; if (q1 > q && q2 > q) {
				for (ichan = 0; ichan < nchan; ichan++) {
					eeg[ichan][isweep][i] = 0.5*(eeg[ichan][isweepp][ip] + eeg[ichan][isweepm][im]);
				}
				nspike++;
				printf ("#spike removed sweep %3d point %4d\n", isweep + 1, i + 1);
			}
		}
	}
	printf ("#total spikes removed = %d\n", nspike);

/*************************************/
/* compute channel artifact signal */
/*************************************/
	for (ichan = 0; ichan < nchan; ichan++) {
		for (isweep = 0; isweep < nsweep; isweep++) {
			for (i = q = 0; i < points; i++) {
				q += eeg[ichan][isweep][i]*eeg[ichan][isweep][i];
			}
			trodsd[ichan][isweep][1] = sqrt(q/points);
		}
	}
	for (ichan = k = 0; ichan < nchan; ichan++) {
		for (isweep = 0; isweep < nsweep; isweep++) {
			if (trodsd[ichan][isweep][1] > 2*arthresh[0]/3) {
				trodsd[ichan][isweep][2] = 50.;
				k++;
			}
		}
		/*if (k > nsweep/2) printf ("#%s may be a bad electrode\n", trode[ichan]);*/
	}

if (!zempel) {
/***********************************/
/* compute general artifact signal */
/***********************************/
	printf ("#quantitating artifact using channels");
	for (jchan = 0; jchan < ACHAN; jchan++) if (strlen (artrode[jchan])) printf (" %s", artrode[jchan]); printf ("\n");
	for (ii = isweep = 0; isweep < nsweep; isweep++) {
		for (i = 0; i < points; i++) {
			for (n = q = jchan = 0; jchan < ACHAN; jchan++) for (ichan = 0; ichan < nchan; ichan++) {
				if (strcmp (artrode[jchan], trode[ichan])) continue;
				q += eeg[ichan][isweep][i]*eeg[ichan][isweep][i];
				n++;
			}
			artifact[0][ii++] = sqrt (q/n);
		}
	}
	for (ii = 0; ii < nsweep*points; ii++) {
		artifact[1][ii] = sum = 0;
		for (i = -aitime*rate; i <= aitime*rate; i++) {
			if (ii + i < 0 || ii + i >= nsweep*points) continue;
			w = 1. - fabs (i/(aitime*rate + 1));
			artifact[1][ii] += w*artifact[0][ii + i];
			sum += w;
		}
		artifact[1][ii] /= sum;
	}
	for (ii = 0; ii < nsweep*points; ii++) {
		if (artifact[0][ii] > arthresh[0] || artifact[1][ii] > arthresh[1]) artifact[2][ii] = 50.;
	}
} else {
/************************************************/
/* parse John Zempel's artifact assessment file */
/************************************************/
	sprintf (layfile, "%s.lay", layroot);
	fprintf (stderr, "#Reading: %s\n", layfile);
	if (!(layfp = fopen (layfile, "r"))) errr (program, layfile);
	i = 0;
	do {
		fgets (string, 4*MAXL, layfp);
	} while (!strstr (string, "Comments"));
	fgets (string, 4*MAXL, layfp);
	do {
		m = split (string, srgv, MAXL);
		if (m != 6) {
			fprintf (stderr, "%s: %s format error (number of fields in line != 6)\n", program, datfile);
			exit (-1);
		}
		zempart[i] = (rate * atof (srgv[0]));
		zempdur[i] = (rate * atof (srgv[1])) + 0.5;	
		i++;
	} while (fgets (string, 4*MAXL, layfp) && i < MAXL);
	for (k = 0; k < i; k++) {
		for (l = zempart[k]; l < (zempart[k] + zempdur[k]); l++) {
			if (l < pointsbeforeMR) continue;
			if (l - pointsbeforeMR >= nsweep*points) break;
			artifact[2][l - pointsbeforeMR] = 50.;
		}
	}
	if (fclose (layfp)) errr (program, layfile);
}

/*****************/
/* accept nsweep */
/*****************/
	for (isweep = 0; isweep < nsweep; isweep++) accept[isweep] = 1;
	printf ("#sweeps rejected:");
	for (ii = isweep = 0; isweep < nsweep; isweep++) {
		for (i = 0; i < points; i++) if (artifact[2][isweep*points + i] > 0) accept[isweep] = 0;
		if (!accept[isweep]) printf (" %d", isweep + 1);
	}
	printf ("\n");

	if (artdump) {
/*****************/
/* dump artifact */
/*****************/
		sprintf (outfile, "%s_artdump.dat", datroot);
		if (!(outfp = fopen (outfile, "w"))) errw (program, outfile);
		fprintf (stderr, "Writing: %s\n", outfile);
		fprintf (outfp, "#%s", program);
		for (i = 1; i < argc; i++) fprintf (outfp, " %s", argv[i]); fprintf (outfp, "\n");
		fprintf (outfp, "#%s\n", rcsid);
		fprintf (outfp, "#general artifact threshold = {%.2f, %.2f})\n", arthresh[0], arthresh[1]);
		fprintf (outfp, "#nsweep rejected:");
		for (i = 0; i < nsweep; i++) if (!accept[i]) fprintf (outfp, " %d", i + 1);
		fprintf (outfp, "\n");
		for (ii = isweep = 0; isweep < nsweep; isweep++) for (i = 0; i < points; i++) {
			fprintf (outfp, "%10.4f", ii*delta);
			for (k = 0; k < NA; k++) fprintf (outfp, " %8.2f", artifact[k][ii]); fprintf (outfp, "\n");
			ii++;
		}
		if (fclose (outfp)) errw (program, outfile);
	}

if (outputNS) {
/*********************/
/* write NS dat file */
/*********************/
	sprintf (NSoutfile, "%s_%s.dat", datroot, trailer);
	fprintf (stderr, "#Writing: %s\n", NSoutfile);
	if (!(outfp = fopen (NSoutfile, "w"))) errw (program, NSoutfile);
	fprintf (outfp, "[Subject]\n");
	fprintf (outfp, "[Date]\t%s\n", date);
	fprintf (outfp, "[Time]\t%s\n", time);
	fprintf (outfp, "[Channels]\t%i\n", channels);
	fprintf (outfp, "[Rate]\t%10.6f\n", rate);
	fprintf (outfp, "[Type]\tContinuous\n");
	fprintf (outfp, "[Rows]\t%s\n", rows);
	fprintf (outfp, "[Electrode Labels]\n");
	for (i = 0; i < nchan; i++) fprintf (outfp, "[\t%s]\t", trode[i]);
	fprintf (outfp, "\n");
	fprintf (outfp, "[Electrode XUnits]\n");
	for (i = 0; i < nchan; i++) fprintf (outfp, "[ Default]\t");
	fprintf (outfp, "\n");
	fprintf (outfp, "[Electrode YUnits]\n");
	for (i = 0; i < nchan; i++) fprintf (outfp, "[ Default]\t");
	fprintf (outfp, "\n");
	fprintf (outfp, "[Continuous Data]\n");
	for (isweep = 0; isweep < nsweep; isweep++) {
		for (i = 0; i < points; i++) { 
			for (ichan = 0; ichan < nchan; ichan++) {
				fprintf (outfp, "%10.4f\t", eeg[ichan][isweep][i]);
			}
			fprintf (outfp, "\n");
		}
	}
	if (fclose (outfp)) errw (program, NSoutfile);
}

	if (idump != -1) {
/***********************/
/* dump selected epoch */
/***********************/
		if (idump < 0 || idump >= nsweep) {
			fprintf (stderr, "%s: requested sweep (%d) not in %s\n", program, idump + 1, datfile);
			goto FREE;
		}
		for (i = 0; i < points; i++) {
			printf ("%-10d", i);
			for (ichan = 0; ichan < nchan; ichan++) printf (" %8.2f", eeg[ichan][idump][i]);
			printf ("\n");
		}
		goto FREE;
	}

	if (strlen (dumpchan)) {
/*************************/
/* dump selected channel */
/*************************/
		for (ichan = 0; ichan < nchan; ichan++) if (!strcmp (trode[ichan], dumpchan)) break;
		if (ichan == nchan) {
			fprintf (stderr, "%s: requested channel (%s) not in %s\n", program, dumpchan, datfile);
			goto FREE;
		}
		sprintf (outfile, "%s_dump_%s.dat", datroot, dumpchan);
		if (!(outfp = fopen (outfile, "w"))) errw (program, outfile);
		fprintf (stderr, "Writing: %s\n", outfile);
		fprintf (outfp, "#%s", program);
		for (i = 1; i < argc; i++) fprintf (outfp, " %s", argv[i]); fprintf (outfp, "\n");
		fprintf (outfp, "#%s\n", rcsid);
		fprintf (outfp, "#dump %s and instantaneous accept\n", trode[ichan]);
		for (ii = isweep = 0; isweep < nsweep; isweep++) for (i = 0; i < points; i++) {
			q = ii*delta;
			k = (artifact[2][ii] == 0) ? 1 : 0;
			fprintf (outfp, "%10.4f%15.4f%5d\n", q, eeg[ichan][isweep][i], k);
			ii++;
		}
		if (fclose (outfp)) errw (program, outfile);
		goto FREE;
	}

/********************************************************/
/* determine channel selected for power analysis output */
/********************************************************/
	if (strlen (pwrchan)) {
		for (schan = 0; schan < nchan; schan++) if (!strcmp (trode[schan], pwrchan)) break;
		if (strlen (pwrchan) && schan == nchan) {
			fprintf (stderr, "%s: selected channel (%s) not found\n", pwrchan);
			exit (-1);
		}
	}

/*******************************/
/* FFT all channels and sweeps */
/*******************************/
	for (ichan = 0; ichan < nchan; ichan++) {
		for (ksweep = isweep = 0; isweep < nsweep; isweep++) {
			if (!accept[isweep]) continue;
			ksweep++;
			for (sum = var = i = 0; i < points; i++) {
				sum += eeg[ichan][isweep][i];
				var += eeg[ichan][isweep][i]*eeg[ichan][isweep][i];
			}
			sum /= points; var /= points; var -= sum*sum;
			for (i = j = 0; j < no2; j++) {
				a[j] = eeg[ichan][isweep][i++];
				b[j] = eeg[ichan][isweep][i++];
			}
			fft_   (a, b, &one, &no2, &one, &negone);
			realt_ (a, b, &one, &no2, &one, &negone);
			totpwr = a[no2]*a[no2];
			for (i = 1; i < no2; i++) totpwr += 2.*(a[i]*a[i] + b[i]*b[i]);
			totpwr /= points*points;
			if (debug) {
				printf ("mean by two methods %10.4f%10.4f\n", sum, a[0]/points);
				printf ("channel=%-8s  sweep=%d variance by two methods %10.1f%10.1f\n",
					trode[ichan], isweep + 1, totpwr, var);
			}
			iband = 0; for (i = 1; i < no2; i++) {
				bandpwr[ichan][isweep][iband] += 2.*(a[i]*a[i] + b[i]*b[i])/(points*points);
				if (hzpbin * (i - 0.5) > bandlim[iband]) iband++;
				if (iband == nband) break;
			}
			psd[ichan][0] += a[0]*a[0];
			for (i = 1; i < no2; i++) psd[ichan][i] += 2.*(a[i]*a[i] + b[i]*b[i]);
			psd[ichan][no2] += a[no2]*a[no2];
			if (debug) {
				printf ("channel=%-8s  sweep=%d\t", trode[ichan], isweep + 1);
				for (iband = 0; iband < nband; iband++) {
					printf ("%10.4f", sqrt (bandpwr[ichan][isweep][iband]));
				}
				printf ("\n");
			}
		}
		for (i = 0; i < nbin; i++) psd[ichan][i] /= (points*points*ksweep);

/***********************************************/
/* interpolate band power over rejected epochs */
/***********************************************/
		if (debug) for (i = 0; i < nsweep; i++) printf ("accept[%d]=%d\n", i, accept[i]);
		for (iband = 0; iband < nband; iband++) {
			for (i1 = 0; i1 < nsweep; i1++) {
				if (accept[i1]) continue;
				for (i2 = i1; i2 < nsweep; i2++) if (accept[i2]) break;
				if (!i1) {
					if (i2 == nsweep) {
						fprintf (stderr, "%s: all epochs rejected %s\n", program, datfile);
						exit (-1);
					} else {
						for (i = i1; i < i2; i++) {
							bandpwr[ichan][i][iband] = bandpwr[ichan][i2][iband];
						}
					}
				} else {
					if (i2 < nsweep) {
						q = (bandpwr[ichan][i2][iband] - bandpwr[ichan][i1 - 1][iband]);
						q /= (i2 - i1 + 1);
					} else {
						q = 0.;
					}
					for (i = i1; i < i2; i++) {
						bandpwr[ichan][i][iband] = bandpwr[ichan][i1 - 1][iband] + q*(i - i1 + 1);
					}
				}
				i1 = i2;
			}
		}		/* iband */
	}			/* ichan */

	if (!strlen (pwrchan)) goto FREE;
/******************************************************/
/* output power split into bands for selected channel */
/******************************************************/
	sprintf (outfile, "%s_%s.dat", datroot, pwrchan);
	if (!(outfp = fopen (outfile, "w"))) errw (program, outfile);
	fprintf (stderr, "Writing: %s\n", outfile);
	fprintf (outfp, "#%s", program);
	for (i = 1; i < argc; i++) fprintf (outfp, " %s", argv[i]); fprintf (outfp, "\n");
	fprintf (outfp, "#%s\n", rcsid);
	fprintf (outfp, "#first point used: %d\n", pointsbeforeMR);
	fprintf (outfp, "#%s\n", pwrchan);
	fprintf (outfp, "#%9s", "time(sec)");
	for (iband = 0; iband < nband; iband++) fprintf (outfp, "%10s", bandlabel[iband]);
	fprintf (outfp, "    accept\n");
	for (isweep = 0; isweep < nsweep; isweep++) {
		fprintf (outfp, "%10.4f", isweep*points/rate);
		for (iband = 0; iband < nband; iband++) fprintf (outfp, "%10.1f", bandpwr[schan][isweep][iband]);
		fprintf (outfp, "%10d\n", accept[isweep]);
	}
	if (fclose (outfp)) errw (program, outfile);

	if (psdflag) {
/********************************/
/* write power spectral density */
/********************************/
		sprintf (outfile, "%s_%s.psd", datroot, pwrchan);
		if (!(outfp = fopen (outfile, "w"))) errw (program, outfile);
		fprintf (stderr, "Writing: %s\n", outfile);
		fprintf (outfp, "#%s", program);
		for (i = 1; i < argc; i++) fprintf (outfp, " %s", argv[i]); fprintf (outfp, "\n");
		fprintf (outfp, "#%s\n", rcsid);
		fprintf (outfp, "#%s\n", pwrchan);
		fprintf (outfp, "%10.4f%10.1f\n", 0., 0.);
		for (i = 0; i < nbin; i++) {
			fprintf (outfp, "%10.4f%10.1f\n",       i*hzpbin, psd[schan][i]);
			fprintf (outfp, "%10.4f%10.1f\n", (i + 1)*hzpbin, psd[schan][i]);
		}
		fprintf (outfp, "%10.4f%10.1f\n", nbin*hzpbin, psd[schan][no2]);
		if (fclose (outfp)) errw (program, outfile);
	}

/***************/
/* free memory */
/***************/
FREE:	
	free_float2 (psd,     nchan);
	free (a); free (b); free (zempdur); free (zempart);
	free_float3 (trodsd,  nchan, nsweep);
	free_float3 (bandpwr, nchan, nsweep);
	for (k = 0; k < NA; k++) free (artifact[k]);
	free (accept); free (frame);
	free_float3 (eeg,     nchan, nsweep);
	exit (status);
}
